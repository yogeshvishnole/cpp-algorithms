<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Fred Swartz (www.fredosaurus.com)"/>
    <link rel="stylesheet" type="text/css" href="../notes.css"/>
    <script type="text/JavaScript" src="../notes.js"></script>
  <title>C++: STL: Containers: Introduction</title>
</head>

<body>
<h1><a href="../index.html">C++ Notes</a>: STL: Containers: Introduction</h1>
The STL (Standard Template Library) provides a number of predefined
containers (data structures), most of which are generalize as templates to hold
any type element.  By far the most commonly used are <code>string</code> and
<code>vector</code>.

<h3>Sequence containers</h3>
    These containers hold sequences of data elements.
        <ul>
        <li><b><a href="vector/header-vector.html"><code>vector</code></a></b> 
            provides a dynamic array structure
            with fast random access to any element.  Inserting and deleting 
            elements at the end is fast.  Can do subscript bounds checking.
            </li>
        <li><b><code>deque</code></b> also provides a dynamic array structure
            with random access and adds fast insertion and deletion of elements
            at front as well as from the back.  Very slightly slower than <code>vector</code>
            because of an extra level of indirection.
            </li>
        <li><b><code>list</code></b> is usually implemented as a doubly linked list.  There is no
            random access to the elements.   Insertion and deletion
            anywhere is fast.
            </li>
        </ul>

<h3>Associative containers</h3>
    Associative containers contain key/value pairs, providing access to 
        each <i>value</i> using a <i>key</i>.  The elements are sorted by the key.
        Usually implemented as a balanced binary tree.
        <ul>
        <li><b><code>map</code></b> provides access to elements using any
            type of <i>key</i>.  This is a generalization of the idea of accessing
            a vector with an integer subscript.
            </li>
        <li><b><code>multimap</code></b> is the same as <code>map</code>, but
            allows a key to map into more than one element.
            </li>
        </ul>

<h3>Ordered sets</h3>
    The set containers keep the elements in them in order, and are
        usually implemented as balanced binary trees.
        They do not implement standard set operations (union, intersection, ...)
        as you might expect from the name.
        <ul>
        <li><b><code>set</code></b> orders the elements that are added to it.
            A set contains only one copy of any value added to it.
            </li>
        <li><b><code>multiset</code></b> is like <code>set</code> but allows
            more than one entry with the same value.
            </li>
        </ul>
        
<h3>Container adapters</h3>
    These are based on other containers, and are used only to enforce
        access rules.  
        Because there are special access restrictions, they have no iterators.
        <ul>
        <li><b><code>stack</code></b> allows only LIFO (Last In, First Out) access.
            </li>
        <li><b><code>queue</code></b> allows only FIFO (First In, First Out) access.
            </li>
        <li><b><code>priority_queue</code></b> always returns the element with
            the highest priority.
            </li>
        </ul>
        
<h3>Specialized containers</h3>
    The following containers are specialized in some ways: specific data type,
        special utility routines, limited, but fast, implementations.
        <ul>
        <li><b><a href="../strings/header-string.html"><code>string</code></a></b> holds character strings - similar to <code>vector&lt;char&gt;</code>,
            but with many useful utility functions.
            </li>
        <li><b><code>bitset</code></b> is a storage-efficient data structure for bits.
            By defining the bit operations, it effectively implements set operations.
            </li>
        <li><b><code>valarray</code></b> is an especially efficient implementation of
            arrays, but it doesn't have all the standard container behavior.
            </li>
        </ul>


<script type="text/JavaScript">footer("2003");</script>
</body>
</html>

