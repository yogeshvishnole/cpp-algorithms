<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="Fred Swartz (www.fredosaurus.com)"/>
    <link rel="stylesheet" type="text/css" href="../../notes.css"/>
    <script type="text/JavaScript" src="../../notes.js"></script>
    <title>C++ Notes: Algorithms: Binary Search</title>
</head>
<body>
<h1><a href="../../index.html">C++ Notes</a>: Algorithms: Binary Search</h1>

<h2>Divide in half</h2>
A fast way to search a sorted array is to use a <i>binary search</i>.
The idea is to look at the element in the middle.  
If the key is equal to that, the search is finished.
If the key is less than the middle element, do a binary search on the first half.  
If it's greater, do a binary search of the second half.

<h2>Performance</h2>
The advantage of a binary search over a linear search is astounding
for large numbers.  For an array of a million elements, binary search, O(log N),  will find
the target element with a worst case of only 20 comparisons.  Linear search, O(N),
on average will take 500,000 comparisons to find the element.
Probably the only faster kind of search uses <i>hashing</i>, a topic that
isn't covered in these notes.

<p>This performance comes at a price - the array must be sorted first.
Because sorting isn't a fast operation, it may not be worth the effort to
sort when there are only a few searches.
</p>

<h2>Example</h2>
<pre class="example">
int binarySearch(int sortedArray[], int first, int last, int key) {
   // function:
   //   Searches sortedArray[first]..sortedArray[last] for key.  
   // returns: index of the matching element if it finds key, 
   //         otherwise  -(index where it could be inserted)-1.
   // parameters:
   //   sortedArray in  array of sorted (ascending) values.
   //   first, last in  lower and upper subscript bounds
   //   key         in  value to search for.
   // returns:
   //   index of key, or -insertion_position -1 if key is not 
   //                 in the array. This value can easily be
   //                 transformed into the position to insert it.
   
   while (first &lt;= last) {
       int mid = (first + last) / 2;  // compute mid point.
       if (key &gt; sortedArray[mid]) 
           first = mid + 1;  // repeat search in top half.
       else if (key &lt; sortedArray[mid]) 
           last = mid - 1; // repeat search in bottom half.
       else
           return mid;     // found it. return position /////
   }
   return -(first + 1);    // failed to find key
}</pre>

<h2>Related Pages</h2>

<a href="linearsearch.html">Linear Search</a>,
<a href="rbinarysearch.html">Recursive Binary Search</a>

   
<script type="text/JavaScript">footer("1999");</script>

</body>
</html>

